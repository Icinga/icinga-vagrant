# !!! generated by puppet !!!
# -*- coding: latin-1 -*-

#####################################
# General Configuration #
#####################################
# Set this to a long, random unique string to use as a secret key for this
# install. This key is used for salting of hashes used in auth tokens,
# CRSF middleware, cookie storage, etc. This should be set identically among
# instances if used behind a load balancer.
SECRET_KEY = '<%= scope.lookupvar('graphite::secret_key') %>'

# In Django 1.5+ set this to the list of hosts your graphite instances is
# accessible as. See:
# https://docs.djangoproject.com/en/dev/ref/settings/#std:setting-ALLOWED_HOSTS
#ALLOWED_HOSTS = [ '*' ]

# Set your local timezone (Django's default is America/Chicago)
# If your graphs appear to be offset by a couple hours then this probably
# needs to be explicitly set to your local timezone.
TIME_ZONE = '<%= scope.lookupvar('graphite::gr_timezone') %>'

# Override this to provide documentation specific to your Graphite deployment
#DOCUMENTATION_URL = "http://graphite.readthedocs.org/"

# Logging
LOG_RENDERING_PERFORMANCE = <%= scope.lookupvar('graphite::gr_log_rendering_performance') %>
LOG_CACHE_PERFORMANCE = <%= scope.lookupvar('graphite::gr_log_cache_performance') %>
LOG_METRIC_ACCESS = <%= scope.lookupvar('graphite::gr_log_metric_access') %>

# Enable full debug page display on exceptions (Internal Server Error pages)
#DEBUG = True

# If using RRD files and rrdcached, set to the address or socket of the daemon
#FLUSHRRDCACHED = 'unix:/var/run/rrdcached.sock'

# This lists the memcached servers that will be used by this webapp.
# If you have a cluster of webapps you should ensure all of them
# have the *exact* same value for this setting. That will maximize cache
# efficiency. Setting MEMCACHE_HOSTS to be empty will turn off use of
# memcached entirely.
#
# You should not use the loopback address (127.0.0.1) here if using clustering
# as every webapp in the cluster should use the exact same values to prevent
# unneeded cache misses. Set to [] to disable caching of images and fetched data
#MEMCACHE_HOSTS = ['10.10.10.10:11211', '10.10.10.11:11211', '10.10.10.12:11211']

<% unless [:undef, nil].include? scope.lookupvar('graphite::gr_memcache_hosts') -%>
MEMCACHE_HOSTS = ['<%= scope.lookupvar('graphite::gr_memcache_hosts').join("','") %>']
<% end -%>

#DEFAULT_CACHE_DURATION = 60 # Cache images and data for 1 minute

<% if scope.lookupvar('graphite::gr_disable_webapp_cache') -%>
# disable cache to reduce graph errors
# https://github.com/graphite-project/graphite-web/issues/576#issuecomment-36246428
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    },
}

<% end -%>

#####################################
# Filesystem Paths #
#####################################
# Change only GRAPHITE_ROOT if your install is merely shifted from /opt/graphite
# to somewhere else
#GRAPHITE_ROOT = '/opt/graphite'

# Most installs done outside of a separate tree such as /opt/graphite will only
# need to change these three settings. Note that the default settings for each
# of these is relative to GRAPHITE_ROOT
#CONF_DIR = '/opt/graphite/conf'
#STORAGE_DIR = '/opt/graphite/storage'
#CONTENT_DIR = '/opt/graphite/webapp/content'
CONF_DIR = '<%= scope.lookupvar('graphite::graphiteweb_conf_dir_REAL') %>'
STORAGE_DIR = '<%= scope.lookupvar('graphite::graphiteweb_storage_dir_REAL') %>'
CONTENT_DIR = '<%= scope.lookupvar('graphite::graphiteweb_webapp_dir_REAL') %>/content'

# To further or fully customize the paths, modify the following. Note that the
# default settings for each of these are relative to CONF_DIR and STORAGE_DIR
#
## Webapp config files
#DASHBOARD_CONF = '/opt/graphite/conf/dashboard.conf'
#GRAPHTEMPLATES_CONF = '/opt/graphite/conf/graphTemplates.conf'

## Data directories
# NOTE: If any directory is unreadable in DATA_DIRS it will break metric browsing
WHISPER_DIR = '<%= scope.lookupvar('graphite::local_data_dir_REAL') %>'
RRD_DIR = '<%= scope.lookupvar('graphite::rrd_dir_REAL') %>'
<%
  if scope.lookupvar('graphite::gr_cache_instances')
    cache_instances = scope.lookupvar('graphite::gr_cache_instances')
  end
  whisper_dirs = Array.new
  #if cache_instances != nil
   cache_instances.each do |name, params|
      if params["LOCAL_DATA_DIR"] then
        whisper_dirs << params["LOCAL_DATA_DIR"]
      end
   end
  unless whisper_dirs.empty? %>
DATA_DIRS = [WHISPER_DIR, RRD_DIR,<%= whisper_dirs.map{|s| "'#{s}'" }.join(',') %>] # Default: set from the above variables
<% end -%>
LOG_DIR = '<%= scope.lookupvar('graphite::graphiteweb_log_dir_REAL') %>'
#INDEX_FILE = '/opt/graphite/storage/index'  # Search index file


#####################################
# Email Configuration #
#####################################
# This is used for emailing rendered Graphs
# Default backend is SMTP
#EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
#EMAIL_HOST = 'localhost'
#EMAIL_PORT = 25
#EMAIL_HOST_USER = ''
#EMAIL_HOST_PASSWORD = ''
#EMAIL_USE_TLS = False
# To drop emails on the floor, enable the Dummy backend:
#EMAIL_BACKEND = 'django.core.mail.backends.dummy.EmailBackend'


#####################################
# Authentication Configuration #
#####################################
<% if scope.lookupvar('graphite::gr_use_ldap') %>
USE_LDAP_AUTH = True
LDAP_URI = "<%= scope.lookupvar('graphite::gr_ldap_uri') %>"
LDAP_SEARCH_BASE = "<%= scope.lookupvar('graphite::gr_ldap_search_base') %>"
LDAP_BASE_USER = "<%= scope.lookupvar('graphite::gr_ldap_base_user') %>"
LDAP_BASE_PASS = "<%= scope.lookupvar('graphite::gr_ldap_base_pass') %>"
LDAP_USER_QUERY = "<%= scope.lookupvar('graphite::gr_ldap_user_query') %>"
<% else %>
## LDAP / ActiveDirectory authentication setup
#USE_LDAP_AUTH = True
#LDAP_SERVER = "ldap.mycompany.com"
#LDAP_PORT = 389
#	OR
#LDAP_URI = "ldaps://ldap.mycompany.com:636"
#LDAP_SEARCH_BASE = "OU=users,DC=mycompany,DC=com"
#LDAP_BASE_USER = "CN=some_readonly_account,DC=mycompany,DC=com"
#LDAP_BASE_PASS = "readonly_account_password"
#LDAP_USER_QUERY = "(username=%s)"  #For Active Directory use "(sAMAccountName=%s)"
<% end %>

# If you want to further customize the ldap connection options you should
# directly use ldap.set_option to set the ldap module's global options.
# For example:
#
#import ldap
#ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)
#ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, "/etc/ssl/ca")
#ldap.set_option(ldap.OPT_X_TLS_CERTFILE, "/etc/ssl/mycert.pem")
#ldap.set_option(ldap.OPT_X_TLS_KEYFILE, "/etc/ssl/mykey.pem")
# See http://www.python-ldap.org/ for further details on these options.

<% if scope.lookupvar('graphite::gr_use_ldap') and scope.lookupvar('graphite::gr_ldap_options') -%>
import ldap
<% scope.lookupvar('graphite::gr_ldap_options').sort.map do |k, v| -%>
ldap.set_option(<%= k %>, <%= v %>)
<% end -%>
<% end -%>

## REMOTE_USER authentication. See: https://docs.djangoproject.com/en/dev/howto/auth-remote-user/
# NOTE - this has been moved to the bottom to gain access to app_settings.

# Override the URL for the login link (e.g. for django_openid_auth)
#LOGIN_URL = '/account/login'


##########################
# Database Configuration #
##########################
# By default sqlite is used. If you cluster multiple webapps you will need
# to setup an external database (such as MySQL) and configure all of the webapp
# instances to use the same database. Note that this database is only used to store
# Django models such as saved graphs, dashboards, user preferences, etc.
# Metric data is not stored here.
#
# DO NOT FORGET TO RUN 'manage.py syncdb' AFTER SETTING UP A NEW DATABASE
#
# The following built-in database engines are available:
#  django.db.backends.postgresql          # Removed in Django 1.4
#  django.db.backends.postgresql_psycopg2
#  django.db.backends.mysql
#  django.db.backends.sqlite3
#  django.db.backends.oracle
#
# The default is 'django.db.backends.sqlite3' with file 'graphite.db'
# located in STORAGE_DIR
#
<% if scope.lookupvar('graphite::gr_django_1_4_or_less') %>
DATABASE_ENGINE = '<%= scope.lookupvar('graphite::gr_django_db_engine') %>'
DATABASE_NAME = '<%= scope.lookupvar('graphite::gr_django_db_name') %>'
DATABASE_USER = '<%= scope.lookupvar('graphite::gr_django_db_user') %>'
DATABASE_PASSWORD = '<%= scope.lookupvar('graphite::gr_django_db_password') %>'
DATABASE_HOST = '<%= scope.lookupvar('graphite::gr_django_db_host') %>'
DATABASE_PORT = '<%= scope.lookupvar('graphite::gr_django_db_port') %>'
<% else %>
DATABASES = {
   'default': {
        'ENGINE': '<%= scope.lookupvar('graphite::gr_django_db_engine') %>',
        'NAME': '<%= scope.lookupvar('graphite::gr_django_db_name') %>',
        'USER': '<%= scope.lookupvar('graphite::gr_django_db_user') %>',
        'PASSWORD': '<%= scope.lookupvar('graphite::gr_django_db_password') %>',
        'HOST': '<%= scope.lookupvar('graphite::gr_django_db_host') %>',
        'PORT': '<%= scope.lookupvar('graphite::gr_django_db_port') %>',
    }
}
<% end %>


#########################
# Cluster Configuration #
#########################
# (To avoid excessive DNS lookups you want to stick to using IP addresses only in this entire section)
#
# This should list the IP address (and optionally port) of the webapp on each
# remote server in the cluster. These servers must each have local access to
# metric data. Note that the first server to return a match for a query will be
# used.
<% if [:undef, nil].include? scope.lookupvar('graphite::gr_cluster_servers') -%>
#CLUSTER_SERVERS = ["10.0.2.2:80", "10.0.2.3:80"]

## These are timeout values (in seconds) for requests to remote webapps
#REMOTE_STORE_FETCH_TIMEOUT = 6   # Timeout to fetch series data
#REMOTE_STORE_FIND_TIMEOUT = 2.5  # Timeout for metric find requests
#REMOTE_STORE_RETRY_DELAY = 60    # Time before retrying a failed remote webapp
#REMOTE_FIND_CACHE_DURATION = 300 # Time to cache remote metric find results

<% else %>
CLUSTER_SERVERS = ['<%= scope.lookupvar('graphite::gr_cluster_servers').join("','") %>']

# Remote cluster settings config names changed in Graphite 1.0.
# See https://github.com/echocat/puppet-graphite/pull/356 for more info
<% if scope.lookupvar('graphite::version_1') >= 0 %>
REMOTE_FETCH_TIMEOUT = <%= scope.lookupvar('graphite::gr_cluster_fetch_timeout') %>
REMOTE_FIND_TIMEOUT = <%= scope.lookupvar('graphite::gr_cluster_find_timeout') %>
REMOTE_RETRY_DELAY = <%= scope.lookupvar('graphite::gr_cluster_retry_delay') %>
FIND_CACHE_DURATION = <%= scope.lookupvar('graphite::gr_cluster_cache_duration') %>
<% else %>
REMOTE_STORE_FETCH_TIMEOUT = <%= scope.lookupvar('graphite::gr_cluster_fetch_timeout') %>
REMOTE_STORE_FIND_TIMEOUT = <%= scope.lookupvar('graphite::gr_cluster_find_timeout') %>
REMOTE_STORE_RETRY_DELAY = <%= scope.lookupvar('graphite::gr_cluster_retry_delay') %>
REMOTE_FIND_CACHE_DURATION = <%= scope.lookupvar('graphite::gr_cluster_cache_duration') %>
<% end %>

<% end %>

## Prefetch cache
# set to True to fetch all metrics using a single http request per remote server
# instead of one http request per target, per remote server.
# Especially useful when generating graphs with more than 4-5 targets or if
# there's significant latency between this server and the backends. (>20ms)
<% if [:undef, nil].include? scope.lookupvar('graphite::gr_prefetch_cache') -%>
#REMOTE_PREFETCH_DATA = False
<% else %>
REMOTE_PREFETCH_DATA = <%= scope.lookupvar('graphite::gr_prefetch_cache') %>
<% end %>

## Remote rendering settings
# Set to True to enable rendering of Graphs on a remote webapp
#REMOTE_RENDERING = True
# List of IP (and optionally port) of the webapp on each remote server that
# will be used for rendering. Note that each rendering host should have local
# access to metric data or should have CLUSTER_SERVERS configured
#RENDERING_HOSTS = []
#REMOTE_RENDER_CONNECT_TIMEOUT = 1.0
<% unless [:undef, nil].include? scope.lookupvar('graphite::gr_rendering_hosts') -%>
REMOTE_RENDERING = True
RENDERING_HOSTS = ['<%= scope.lookupvar('graphite::gr_rendering_hosts').join("','") %>']
REMOTE_RENDER_CONNECT_TIMEOUT = <%= scope.lookupvar('graphite::gr_rendering_hosts_timeout') %>
<% end %>

# If you are running multiple carbon-caches on this machine (typically behind a relay using
# consistent hashing), you'll need to list the ip address, cache query port, and instance name of each carbon-cache
# instance on the local machine (NOT every carbon-cache in the entire cluster). The default cache query port is 7002
# and a common scheme is to use 7102 for instance b, 7202 for instance c, etc.
#
# You *should* use 127.0.0.1 here in most cases
<% if [:undef, nil].include? scope.lookupvar('graphite::gr_carbonlink_hosts') -%>
#CARBONLINK_HOSTS = ["127.0.0.1:7002:a", "127.0.0.1:7102:b", "127.0.0.1:7202:c"]
#CARBONLINK_TIMEOUT = 1.0
<% else -%>
CARBONLINK_HOSTS = ['<%= scope.lookupvar('graphite::gr_carbonlink_hosts').join("','") %>']
CARBONLINK_TIMEOUT = <%= scope.lookupvar('graphite::gr_carbonlink_hosts_timeout') %>
<% end -%>

# Using 'query-bulk' queries for carbon
# It's more effective, but python-carbon 0.9.13 (or latest from 0.9.x branch) is required
# See https://github.com/graphite-project/carbon/pull/132 for details
#CARBONLINK_QUERY_BULK = False
<% unless [:undef, nil].include? scope.lookupvar('graphite::gr_carbonlink_query_bulk') -%>
CARBONLINK_QUERY_BULK = <%= scope.lookupvar('graphite::gr_carbonlink_query_bulk') %>
<% end -%>

<%- if scope.lookupvar('graphite::gr_graphite_ver') >= '0.9.16' -%>
# Type of metric hashing function.
# The default `carbon_ch` is Graphite's traditional consistent-hashing implementation.
# Alternatively, you can use `fnv1a_ch`, which supports the Fowler-Noll-Vo hash
# function (FNV-1a) hash implementation offered by the carbon-c-relay project
# https://github.com/grobian/carbon-c-relay
#
# Supported values: carbon_ch, fnv1a_ch
#
#CARBONLINK_HASHING_TYPE = 'carbon_ch'
<% unless [:undef, nil].include? scope.lookupvar('graphite::gr_carbonlink_hashing_type') -%>
CARBONLINK_HASHING_TYPE = '<%= scope.lookupvar('graphite::gr_carbonlink_hashing_type') %>'
<% end -%>
<% end -%>

#####################################
# Additional Django Settings #
#####################################
# Uncomment the following line for direct access to Django settings such as
# MIDDLEWARE_CLASSES or APPS
#from graphite.app_settings import *

## REMOTE_USER authentication. See: https://docs.djangoproject.com/en/dev/howto/auth-remote-user/
# NOTE - this has been moved to the bottom to gain access to app_settings.
<%-
if scope.lookupvar('graphite::gr_use_remote_user_auth') == 'True'
    if [:undef, nil].include? scope.lookupvar('graphite::gr_remote_user_header_name')
-%>
USE_REMOTE_USER_AUTHENTICATION = True
<%-
    else
-%>
# NOTE - This puppet module handles this slightly differently to the default Django approach
# with local_settings.py / settings.py
from graphite.app_settings import *
# Primarily when a custom HTTP header is used instead of REMOTE_USER.
MIDDLEWARE_CLASSES += (
    'django.contrib.auth.middleware.RemoteUserMiddleware',
    'graphite.custom_auth.CustomHeaderMiddleware'
)
AUTHENTICATION_BACKENDS.insert(0,'django.contrib.auth.backends.RemoteUserBackend')
# Disable the logic in settings.py that does this in a non-custom way.
USE_REMOTE_USER_AUTHENTICATION = False
<%-
    end
else
-%>
USE_REMOTE_USER_AUTHENTICATION = False
<%-
end
-%>

<% unless scope.lookupvar('graphite::gr_django_1_4_or_less') %>
# Configure static URL prefix for Django admin pages
STATIC_URL = '/static/'
<% end %>
